<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../static/css/report.css" />
    <script src="../static/js/report.js" defer></script>
    <title>Scan Report</title>
  </head>
  <body>

    
    <h1>Vulnerability Scan Result</h1>
    <a href="{{ url_for('home') }}" id="home">Home</a>

    <section>
      <div class="sql">
      <h3>SQL Injection Scan</h3>

    {% for type in sqli_type %}
    <p class="label">Scan Type: <span>{{ type }}</span></p>
    {% endfor %} {% for detected in sqli_detected %}
    <p class="label">SQLi Detected: <span class="sqlid">{{ detected }}</span></p>
    {% endfor %} {% for level in risk_state %}
    <p class="label">Risk Level: <span class="risk">{{ level }}</<span></p>
    {% endfor %}
    {% for d in db %}
    <p class="label">Database Detected: <span>{{ d }}</<span></p>
    {% endfor %}
    <br />


    <p class="scan-details1">Scan Details</p>
    {% for test_log in test_logs %}
    <p class="test-logs">{{ test_log }}</p>
    {% endfor %}
    <br />

    <div class="rec">
      <p class = "reco">Recommendations</p>

      <p class="recom"><span class="recomp">Filter Inputs.</span> use input validation via a function such as MySQL's mysql_real_escape_string() to ensure that any dangerous characters such as ' are not passed to a SQL query in data. You should also sanitize everything by filtering user data by context.</p>
      <p class="recom"><span class="recomp">Don't use dynamic SQL.</span> Even data sanitization routines can be flawed, so use prepared statements, parameterized queries or stored procedures instead whenever possible.</p>
      <p class="recom"><span class="recomp">Use a firewall.</span> Consider a web application firewall (WAF) – either software or appliance-based – to help filter out malicious data.</p>
      
    
    </div>

    

    </div>
    

    <div class="xss">

       <h3>Cross-Site Scripting Scan</h3>
    {% for type in xss_type %}
    <p class="label">Scan Type: <span>{{ type }}</span></p>
    {% endfor %} {% for detected in xss_detected %}
    <p class="label">XSS Detected: <span class="xssd">{{ detected }}</span></p>
    {% endfor %} {% for level in risk_level %}
    <p class="label">Risk Level: <span class="risk risky">{{ level }}</<span></p>
    {% endfor %}
    {% for d in db %}
    <p class="label"></<span></p>
    {% endfor %}
    <br />

    <p class="scan-details">Scan Details</p>
    {% for scan_log in scan_logs %}
    <p class="scan-logs">{{ scan_log }}</p>
    {% endfor %}
    <br />

    <p class="payloads-tried">Payloads Tried</p>
    {% for payload in payloads_tried %}
    <p class="payloads">{{ payload }}</p>
    {% endfor %}
    <br />

    <div class="rec1">
      <p class = "reco1">Recommendations</p>

      <p class="recom1"><span class="recomp">Filter input on arrival.</span> At the point where user input is received, filter as strictly as possible based on what is expected or valid input.</p>
      <p class="recom1"><span class="recomp">Encode data on output.</span> At the point where user-controllable data is output in HTTP responses, encode the output to prevent it from being interpreted as active content. Depending on the output context, this might require applying combinations of HTML, URL, JavaScript, and CSS encoding.</p>
      <p class="recom1"><span class="recomp">Use appropriate response headers.</span> To prevent XSS in HTTP responses that aren't intended to contain any HTML or JavaScript, you can use the Content-Type and X-Content-Type-Options headers to ensure that browsers interpret the responses in the way you intend.</p>
      <p class="recom1"><span class="recomp">Content Security Policy.</span> As a last line of defense, you can use Content Security Policy (CSP) to reduce the severity of any XSS vulnerabilities that still occur.</p>
    
    </div>

    </div>
    </section>


    
   
  </body>
</html>